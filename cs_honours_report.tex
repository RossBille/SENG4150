%
% Honours Report Template
% updated May 2013
%
\documentclass[a4paper,12pt]{article}
\makeatletter
%\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
%{-2.5ex\@plus -1ex \@minus -.25ex}%
%{1.25ex \@plus .25ex}%
%{\normalfont\normalsize\bfseries}}
%\makeatother
%\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
%\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC
%
\usepackage{url}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage[round]{./natbib/natbib}
% It also sets the bibliographystyle to plainnat; for more information on
% natbib citation styles, see the natbib documentation, a copy of which
% is archived at http://www.jmlr.org/format/natbib.pdf
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{color}
%stop splitting words at the end of a line
%\usepackage[none]{hyphenat}

%\graphicspath{{./figures/}
%Formatting-------------------------------------------------------------------
%\renewcommand{\refname}{\textbf{Literature}}
%
\renewcommand{\contentsname}{\small\textbf{{\center Table of Contents}}}
%
\setlength{\textheight}{8.8in}
%
\setlength{\topmargin}{-1.5cm}
%
\doublespacing
%\setlength{\textwidth}{17cm}
%
%\setlength{\oddsidemargin}{-0.1714in}
%
% Boxit -----------------------------------------------------------
\setlength{\fboxrule}{0.2mm} \setlength{\fboxsep}{4mm}
%
\newsavebox{\savepar}
\newenvironment{boxit}{\begin{lrbox}{\savepar}
        \begin{minipage}[b]{4.6in}}
        {\end{minipage}\end{lrbox}\fbox{\usebox{\savepar}}}
        
        
        
        
 \hyphenation{op-tical net-works Mathe-ma-tical street-scape street-scapes aes-the-tics aes-the-tic com-pu-ting geo-metric Geo-me-tric geo-metry boun-da-ries de-ve-lop-ment know-ledge mani-fold mani-folds high-di-men-sio-nal}
%
%
%
% Document-----------------------------------------------------------------------
%
\begin{document}
%
\title{\bf Distributed Operating Systems - Persistence \& State Preservation}
%
\author{Ross Bille - 3127333\\
School of Electrical Engineering \& Computer Science\\
The University of Newcastle\\ Callaghan NSW 2308, Australia\\
Email: \texttt{c3127333@uon.edu.au} } 

\maketitle


\newpage
\begin{abstract}%
\noindent The abstract summarises the content of the paper or report and should have 70-200 words (depending on the publisher or other requirements); It
should state briefly what the paper is about (maybe also what
methods were used), what its (new) results are, why it is
important or significant. It can also be useful to state (or
indicate implicitly) who is the addressed readership and whether
its a review article, a short paper, a pilot study, an
extension of previous work or a thesis. Try to avoid special symbols, abbreviations, and citations.
\end{abstract}

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

There are different ways to write an introduction. Typically it
contains background information and a review of literature which
indicates how the study fits into the context of other previous
work. This way the introduction can  address the significance and importance of the study. Major related publications in big journals should be cited
as well as closely related other articles. The literature review typically uses newer papers when it tries to address the state-of-the-art of a technique or recent developments. However, when first mentioning a method name the historically first source that introduced that concept should be cited. There are different citation styles and here is an example introduction
typically motivates the general hypotheses, aims and research questions
of a paper, report or thesis.  

\begin{center}
\begin{boxit}
\textbf{Persistence \& State Preservation.}
\end{boxit}
\end{center}

Questions raised in the introduction can later be answered in the final discussion.

The introduction often ends with a brief overview of the structure or organisation of
the paper, report or thesis.
test~\citep{ADearle}
%
\section{Persistence}\label{sec:persistence}
Generally in computer science the term persistence is when the data that a process is working on outlives the life of the aforementioned  process. 
The need for persistence is nicely explained by Atkinson;
``Large scale and long-lived application systems, enterprise applications, require persistence, that is provision of storage for many of their data structures.''~\citep[page 1]{persistenceandjava}

\subsection{Conventional Systems}
Conventional systems work in a transient manner; data and processes in these systems don't persist natively because the data that is being executed on exists in volatile main memory. For this reason programmers have had to develop methods of persistence. Conventionally this is done through the use of databases where a programmer needs to create mappings between objects and data in main memory and data in the database.
\subsubsection{Cons}\label{sec:cons}
The negative effects of this methodology are obvious, for instance if the system (or program running on a system) becomes unstable (see section~\ref{sec:preservation}) then all data can be lost. To combat this (as mentioned above) additional work is needed on the programmers behalf to move these objects into non-volatile memory. This not only gives the programmer more work, but also increases the load that a program puts on the system due to database calls which in a lot of languages are ``unable to benefit from compile-time verification and design-time features like IntelliSense.''\citep[page 1]{linqsql}.
\subsubsection{Pros}
Despite the cons mentioned in section~\ref{sec:cons} there are still a few benefits of working in a conventional system. A major benefit is considered to be the use of relational databases to implement persistence and the loose coupling achieved through utilizing one~\citep{Databases}.
A database stores many kinds of data in a standardised way for access by numerous different programs, this creates a loose coupling between the program and its persistent data. As a result of this coupling, it becomes easier to create generic light-weight reports to run over large sets of data without having to write large programs that incorporate this functionality~\citep{XML}.
\subsection{Orthogonal Persistence}\label{sec:orthogonal}
Also known as transparent persistence, orthogonal persistence is an implementation of persistence where the programmer doesn't need to invoke persistence in order to use it, for orthogonal persistence the persistence property should occur in the background, transparent to the programmer and any users.
Three principles of orthogonal persistence were identified by \citet{Atkinson}, these principles are as follows:
\begin{enumerate}
    \item{The Principle of Persistence Independence - Programmer shouldn't be required to invoke persistence;}
    \item{The Principle of Data Type Orthogonality - All data objects are allowed to be persisted; and}
    \item{The Principle of Persistence Identification - The choice of how to identify persistent objects is orthogonal to the universe of discourse of the system.}
\end{enumerate}
These principals tie in nicely with the two principals of orthogonal persistence identified by \citet{Grasshopper}:
\begin{enumerate}
    \item{Any object may persist (exist) for as long, or as short, a period as the object is required; and}
    \item{Objects may be manipulated in the same manner regardless of their longevity.}
\end{enumerate}
\subsection{Implementations of Persistence}\label{sec:persistentLanguages}
The following sections will introduce some persistent programming languages and briefly some of the hurdles encountered with each implementation. These implementations will be compared with the definition of orthogonal persistence given in Section~\ref{sec:orthogonal}.
%PS-algol
\subsubsection{PS-Algol}
%Introduction
An extension of S-Algol, PS-Algol was the first orthogonally persistent programming language. The compiler was largely unchanged as the persistence extensions were implemented at run-time, with a majority of extensions being functions that worked with the database such as:
\begin{itemize}
    \item{open.database(...)}
    \item{close.database(...)}
    \item{commit}
    \item{abandon}
    \item{lookup(...)}
    \item{enter(...)}
\end{itemize}
%how it compares to the orthogonal persistence model
Regardless of its type, when an object is first accessed it is automatically bound to a representation in the database and is used throughout the objects life cycle~\citep{psalgol}. This process reflects the principals of data type orthogonality and persistence identification. This action is done automatically meaning the programmer doesn't need to explicitly move the data between mediums thus achieving persistence independence.
%Napier88
\subsubsection{Napier88}
%introduction - brief desc of the language
Napier88 is another orthogonally persistent programming language\citep{napier}. It differs from PS-Algol with the following improvements~\citep{ADearle}:
\begin{itemize}
    \item{The infinite union type `any';}
    \item{The infinite union type `environment';} 
    \item{Parametric polymorphism; and}
    \item{Support for structural reflection.}
\end{itemize}
%how it compares to the orthogonal persistence model
Napier88 represents a fully integrated persistent environment that makes use of `text' and `hyperlinks' to aid in achieving the principals of persistence independence and data type orthogonality.
\subsubsection{Java}
Out-of-the-box Java is a transient programming language however it does provide interfaces to the programmer to make objects persist. Additionally the Java Virtual Machine (JVM) aids in creating persistent systems (see sections~\ref{sec:grasshopper} and \ref{sec:pjama}) largely due to the abstraction it provides over the conventional operating system is runs on. The following are some persistence implementations.
\par
Java provides interfaces for object serialization and deserialization to assist in persistence, these interfaces make the tasks of writing to and reading from secondary storage simple. Objects must implement the java.io.serializable interface in order to become persistent in this manner, which breaks the rule of data type orthogonality. Data persisted in this manner must also be explicitly written which means it also breaks the principal of persistence independence~\citep{ADearle}.
\par
\label{sec:javahibernate}
%introduction - brief desc of the method
Because Java is so commonly used for large enterprise applications there have been many persistence Application Programming Interfaces (API) developed~\citep{persistenceandjava}. These API's abstract the persistence processes (such as the object to relationship mappings) in order to speed up development time. 
\\One of these persistence API's is Hibernate (not to be confused with section~\ref{sec:hibernate} of this report which refers to system state preservation). Hibernate builds on top of the Enterprise JavaBeans (EJB) and the Java Persistence API's, its main purpose is that of an object-relational mapping (ORM) library~\citep{hibernateORM}. This means it creates the mappings between in-memory objects and database tables and thus assists to provide persistence. Hibernate doesn't provide orthogonal persistence for the following reasons:
\begin{itemize}
    \item{Objects can be marked as persistent or transient, breaking the principal of data type orthogonality; and}
    \item{A store function must be invoked to perform updates or inserts in the database, breaking the principal of persistence independence.}
\end{itemize}
Despite not being orthogonally persistent Hibernate is still widely used in industry.
\par
\label{sec:pjama}
%introduction - brief desc of the method
PJama is a Java system built for persistence, it uses a modified interpreter to run Java programs~\citep{persistentjavasystem} in a persistent manner. PJama can not persist some of the supported data types~\citep{ADearle}, failing the principal of data type orthogonality. 
%problems encountered
%how it compares to the orthogonal persistence model
\par
Language Integrated Query (LINQ)
%introduction - brief desc of the method 
is a Microsoft developed technology similar to Javas Hibernate (see section~\ref{sec:javahibernate}) for use with its visual C\# and visual Basic languages. It provides a single generic interface to access objects both in memory (collections etc) and database entities (through the Entity Framework component) to make the location of objects relatively transparent to the programmer~\citep{ADearle}.
Neither C\# or Basic are orthogonally persistent languages and the addition of LINQ doesn't change that, it simply makes it easier for the programmer to implement persistence.
%problems encountered
%how it compares to the orthogonal persistence model
\par
Grasshopper\label{sec:grasshopper} 
%introduction - brief desc of the language
is an operating system that provides orthogonal persistence~\citep{Grasshopper}. 
The system meets the requirement of persistence independence through the use of containers. Containers represent partitions of the address space which ``provide the only abstraction over storage''~\citep[page 3]{Grasshopper}.
The requirement for data type orthogonality is met through the usage of managers. Managers are responsible for providing data to containers when it is first accessed, they are also responsible for data maintenance when the data is not in RAM \citep{Grasshopper}.
Along with containers and managers, the Grasshopper operating system relies heavily on capabilities and loci to assist in meeting the principal of persistence identification.
%The system relies on containers, loci and capabilities in  order to meet the requirements set out by the principals of persistence independence, data type orthogonality and persistence identification.

%problems encountered
%how it compares to the orthogonal persistence model
\par
\subsection{Persistent Operating Systems}\label{sec:persistentOS}
The components of a persistent system are different to those of a conventional operating system~\citep{Grasshopper} 
\subsubsection{Global Consistency}
Global Checkpointing
\par
Asynchronous Checkpointing
\par
\paragraph{Synchronous Checkpointing}
\par
\subsection{Limitations}\label{sec:limitations}
\subsection{Summary}
key points:
\begin{itemize}
    \item{the need for Persistence isn't well known through industry}
    \item{Orthogonal persistence is difficult to achieve due to the need to implement all 3 principals mentioned in section~\ref{sec:orthogonal}}
\end{itemize}
\section{System State Preservation}\label{sec:preservation}
The state of a system refers to the data and processes that live in that state. The state within conventional operating systems exists in a transient manner, this means that if a failure occurs the state can cease to exist (contrary to the persistent systems mentioned in section~\ref{sec:persistentOS}). In a perfect environment this would not matter however we do not live within a static system. We need to consider inconsistencies such as:
\begin{itemize}
    \item{Power failures}
    \item{Data corruption}
    \item{Limited storage capacity}
    \item{Limited processing power}
    \item{Limited power (encouraging users to close laptop lids or power down machines regularly)}
\end{itemize}
For these reasons we need to develop methods that allow us to recover from the above mentioned inconsistencies, in such a way that once the system comes back online and usable the user can continue to work as if nothing has happened.
\\A number of different methods have already been developed in response to this need, some more effective than others and some that require more resources than others. Sections~\ref{sec:lowpower} and~\ref{sec:memorydump} group these methods by behavior.

\subsection{Low-power}\label{sec:lowpower}
The first group of methods that implement System State Preservation share the characteristic that the system is still running, albeit consuming minimal power. These methods keep primary storage powered while other components of the system are shut down. In these methods the system does not need to write anything to secondary storage upon initiation and therefor will not need to read anything on system startup. For this reason these methods are preferable in systems using solid state drives (SSD). Additionally these types of preservation are generally the quickest methods, only having to wait for all other components to come back online.
\\The following sections describe some examples of the low power method of System State Preservation.

\subsubsection{Suspend to RAM}\label{sec:stRam}
This is a method used by the Linux operating system where power is cut to all components of the system except for RAM which contains all the information in relation to system state.\citep{Wiki}
Suspend to RAM can be initiated by a user or scheduled by the system to save power when the system isn't being directly used. Suspend to RAM is not effective following a complete sudden loss of power due to a power failure.
\subsubsection{PC box Power Management (PCPM)}\label{sec:PCPM}
Used by most Windows computers since Windows 2000, PCPM refers to a form of system state preservation concerned with lowering power consumption of the PC (hard drive, CPU, etc.)~\citep{PCPM}. This method is usually implemented to save laptop battery life or to meet energy standards set by Energy Star in conjunction with Advanced Configuration Power Interface (ACPI)~\citep{PCPM}.
\\
Similar to Linux's method mentioned in section~\ref{sec:stRam}, this method is often referred to as ``sleep'', however some difficulties arose when networking started becoming popular in the industry. Today we see a lot of centrally managed computer environments where an organisation will image all their computers the same way and ``push'' updates when necessary. This became a problem when PCPM was first used as the computer would become disconnected from the network during system sleep. 
For this reason it has been necessary to activate the Wake On Lan (WOL) feature of the operating system. WOL makes it possible for administrators to ``wake'' a computer from ``sleep'' by sending a message through the network interface making it possible for administrators to remotely issue updates~\citep{WOL}. For WOL to function the network interface must be powered as well as the RAM and this is the main difference between the PCPM method and Suspend to RAM methods addressed in section~\ref{sec:stRam}.

\subsection{Memory dump}\label{sec:memorydump}
The next group of methods share the characteristic that they all write the systems state to secondary (non-volatile) storage and completely shut down. This means that the next system start up will function just like a cold start up except that once the system is ready it will read the last valid system state back into RAM.
These methods are the most effective in dealing with laptops that have run out of battery power providing the operating system is configured to perform a system state write before all power is completely lost. These methods are still vulnerable to complete and sudden power losses because they require time to perform the write operations.

\subsubsection{Hibernate}\label{sec:hibernate}
Hibernate is the main implementation of System State Preservation where the entire state is written to secondary storage. It is implemented in most modern operating systems, namely Windows 2000+ (support existed at the hardware level of Windows 95), Mac OSX 10.4+, and Linux since kernel 2.6.
Hibernate can be invoked by a user, scheduled by the system (after a certain period of inactivity) or forced when a low-power state is detected (less than 5\% battery power). Upon invocation the operating system will write the entire contents of RAM to non-volatile secondary storage and commence a complete power down.
Suspend to Disk\label{sec:stDisk} is an implementation of hibernate used in the Linux operating system since kernel 2.6, the entire systems state is saved into swap space and the machine is completely powered off\citep{Wiki}.
Reopen Windows\label{sec:reopen}
is a default option available on Mac OSX 10.8+, this option enables the operating to enter a state of hibernation by default when the user shuts down, this gives the user the impression that the systems state is never lost because every time they power the system up the operating system will read the last valid state from non-volatile memory back into RAM.

\subsection{Hybrid Methods}
As the name suggests these methods are a combination of Sleep and Hibernate. Sections~\ref{sec:stBoth}, \ref{sec:hybridsleep} and \ref{sec:safesleep} explain how Linux, Windows and Apple operating systems (respectively) implement this form of preservation.
Generally these methods write the system state to secondary storage and then enter their low power state (see section~\ref{sec:lowpower}). This means that the system is protected from a total sudden power loss while still allowing for quicker startup times (when compared to the methods mentioned in \ref{sec:memorydump}) provided the power isn't completely lost. 
\subsubsection{Suspend to Both}\label{sec:stBoth}
This is the name given to the combination of the methods explained in section~\ref{sec:stRam} and section~\ref{sec:stDisk} used in the Linux operating system. When a user invokes this method the operating system will take a snapshot of its main memory and save it to the secondary memory.
\subsubsection{Hybrid Sleep}\label{sec:hybridsleep}
This method has been used by the Windows operating systems since Vista. Activated by default in some of the power management plans offered by the operating system, for example the ``Power Saver'' plan which was designed to save power by:
\begin{itemize}
    \item{Stopping the hard drives from spinning when not in use;}
    \item{Lowering Central Processing Unit (CPU) frequency (where applicable); and}
    \item{Activating Hybrid Sleep after short periods of inactivity (usually between 5-15 minutes).}
\end{itemize}
Hybrid sleep was selected for this plan in order to maintain a reasonable ``wake'' time when a user needs to interact with the system again~\citep{windowssleepandhibernation}.
\subsubsection{Safe Sleep}\label{sec:safesleep}
Commonly found in Apple laptops~\citep{safesleep}, safe sleep is an implementation of sleep first take a snapshot of the current systems state and saves it to non-volatile memory. The system then enters a low-power state, with this implementation the user will not lose their work (represented in the system state) even if the battery is completely depleted while in this low-power state.
\subsection{Advance Configuration and Power Interface (ACPI)}
The ACPI defines the current standards for power management \citep{ACPI} and as such have categorized all the methods described throughout this section on system state preservation (section~\ref{sec:preservation}). Table~\ref{table:categories} outlines where these methods are rated in terms of power usage.
\begin{table}[h!]
    \begin{center}
        \leavevmode
        \begin{tabular}{|cll|l|}\hline
            Method & Section & Category\\[0.1cm]\hline
            Suspend to RAM & \ref{sec:stRam} & S3\\
            PCPM & \ref{sec:PCPM} & S3 \\
            Hibernate & \ref{sec:hibernate} & S4\\
            Suspend to Disk & \ref{sec:stDisk} & S4 \\
            Suspend to Both & \ref{sec:stBoth} & S3 \\
            Hybrid Sleep & \ref{sec:hybridsleep} & S3 \\
            Safe Sleep & \ref{sec:safesleep} & S3 \\\hline
        \end{tabular}
    \end{center}
    \caption{ACPI power saving categories \citep{ACPI}}
    \label{table:categories}
\end{table}
\\Rating S3 refers to all methods that consume ``low power'' and rating S4 refers to methods where absolutely no power is used \citep{ACPI}. S1 and S2 do exist (along with many others) but are not concerned with system state preservation and are not included in this report.

\subsection{Additional Techniques}
There are multiple techniques implemented in modern operating systems to assist in the preservation of system state. These techniques are listed in this section because they don't provide preservation independently.
Some of these techniques are as follows:
\subsubsection{Versions and Auto Save}\label{sec:versioning}
Implemented in the latest iterations of Mac OSX (10.8+) is an API for automatic saving and versioning. This API makes it easy for developers to create programs that act in a persistent manner, applications can now be configured to automatically save the users work in the background \citep{versioning}. 
Programs that enable this functionality contribute to making OSX a resilient and reliable system because even if methods such as Safe Sleep (see section~\ref{sec:safesleep}) and Hibernate (see section~\ref{sec:hibernate}) fail completely the automatic versioning should still have access to a recent copy of the users work. As can be seen versioning preserves the state of user data, for example documents, however it does not provide complete system state preservation.

\subsubsection{Journaling}
Similar to the auto save method (see section~\ref{sec:versioning}), journaling on its own cannot provide system  state preservation as it is mainly concerned with keeping the file system stable and not the systems state.
\citep{journaling}
\subsection{Summary}
Operating systems are advancing daily, introducing new technologies (as described in section~\ref{sec:lowpower}) to help with preserving the systems state.
\\
Sleep states are currently the quickest to enter and exit from, this is because no large read/write actions need to be performed, however the case in which total power is lost is better dealt with when the system has entered a state of hibernation (as described in section~\ref{sec:memorydump}).
\\
Hybrid methods of system state preservation (mentioned in section~\ref{sec:preservation}) are more valuable on desktop systems when compared to mobile systems such as laptops. I have come to this conclusion because the only reason the system state needs to be saved is to guard against unexpected power loss, however a laptop operates on battery power which guards against these types of power losses, it's also worth mentioning that most modern battery monitors can detect when power is about to reach critically low levels and can in turn enforce system wide hibernation.
\newpage
\section{Discussion}\label{sec:discussion}
%compare and contrast
Given a completely persistent system there would be no need for methods that preserve a systems state.
%
\section{Conclusion}
%
A brief final summary of the main achievements and outcomes. Possibly some suggestions for future work that can follow on from your project.%
%
\subsection*{Acknowledgements}
The author is grateful to A/Prof Frans Henskens and Mark Wallis for the content presented throughout the course.
\newpage
\section{Glossary}
\textbf{Non-volatile:}
\\\textbf{Object Relational Mapper (ORM):} 
\\\textbf{Push:} Copying data from a source to one or many destinations. 
\\\textbf{Volatile:}
%

\vskip 0.2in
\newpage
\bibliographystyle{apalike}
\bibliography{./literature.bib}

\end{document}
