%
% Honours Report Template
% updated May 2013
%
\documentclass[a4paper,12pt]{article}
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
{-2.5ex\@plus -1ex \@minus -.25ex}%
{1.25ex \@plus .25ex}%
{\normalfont\normalsize\bfseries}}
\makeatother
\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC

%
\usepackage{url}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage[round]{./natbib/natbib}
% It also sets the bibliographystyle to plainnat; for more information on
% natbib citation styles, see the natbib documentation, a copy of which
% is archived at http://www.jmlr.org/format/natbib.pdf
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{color}
%stop splitting words at the end of a line
%\usepackage[none]{hyphenat}

%\graphicspath{{./figures/}
%Formatting-------------------------------------------------------------------
%\renewcommand{\refname}{\textbf{Literature}}
%
\renewcommand{\contentsname}{\small\textbf{{\center Table of Contents}}}
%
\setlength{\textheight}{8.8in}
%
\setlength{\topmargin}{-1.5cm}
%
\doublespacing
%\setlength{\textwidth}{17cm}
%
%\setlength{\oddsidemargin}{-0.1714in}
%
% Boxit -----------------------------------------------------------
\setlength{\fboxrule}{0.2mm} \setlength{\fboxsep}{4mm}
%
\newsavebox{\savepar}
\newenvironment{boxit}{\begin{lrbox}{\savepar}
        \begin{minipage}[b]{4.6in}}
        {\end{minipage}\end{lrbox}\fbox{\usebox{\savepar}}}
        
        
        
        
 \hyphenation{op-tical net-works Mathe-ma-tical street-scape street-scapes aes-the-tics aes-the-tic com-pu-ting geo-metric Geo-me-tric geo-metry boun-da-ries de-ve-lop-ment know-ledge mani-fold mani-folds high-di-men-sio-nal}
%
%
%
% Document-----------------------------------------------------------------------
%
\begin{document}
%
\title{\bf Distributed Operating Systems - Persistence \& State Preservation}
%
\author{Ross Bille - 3127333\\
School of Electrical Engineering \& Computer Science\\
The University of Newcastle\\ Callaghan NSW 2308, Australia\\
Email: \texttt{c3127333@uon.edu.au} } 

\maketitle


\newpage
\begin{abstract}%
\noindent The abstract summarises the content of the paper or report and should have 70-200 words (depending on the publisher or other requirements); It
should state briefly what the paper is about (maybe also what
methods were used), what its (new) results are, why it is
important or significant. It can also be useful to state (or
indicate implicitly) who is the addressed readership and whether
its a review article, a short paper, a pilot study, an
extension of previous work or a thesis. Try to avoid special symbols, abbreviations, and citations.
\end{abstract}

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

There are different ways to write an introduction. Typically it
contains background information and a review of literature which
indicates how the study fits into the context of other previous
work. This way the introduction can  address the significance and importance of the study. Major related publications in big journals should be cited
as well as closely related other articles. The literature review typically uses newer papers when it tries to address the state-of-the-art of a technique or recent developments. However, when first mentioning a method name the historically first source that introduced that concept should be cited. There are different citation styles and here is an example introduction
typically motivates the general hypotheses, aims and research questions
of a paper, report or thesis.  

\begin{center}
\begin{boxit}
\textbf{Persistence \& State Preservation.}
\end{boxit}
\end{center}

Questions raised in the introduction can later be answered in the final discussion.

The introduction often ends with a brief overview of the structure or organisation of
the paper, report or thesis.
test~\citep{ADearle}
%
\section{Persistence}\label{sec:persistence}
Generally in computer science persistence is when the data that a process is working on outlives the life of the aforementioned  process. 
The need for persistence is nicely explained by Atkinson;
``Large scale and long-lived application systems, enterprise applications, require persistence, that is provision of storage for many of their data structures.''~\citep{persistenceandjava}

\subsection{Conventional Systems}
Conventional systems work in a transient manner, data and processes in these systems don't persist natively because the data that is being executed on exists in volatile main memory. For this reason programmers have had to develop methods of persistence. Conventionally this is done through the use of databases where a programmer needs to create mappings between objects and data in main memory and data in the database.
\subsubsection{Cons}\label{sec:cons}
The negative effects of this methodology are obvious, for instance if the system (or program running on a system) becomes unstable (see section~\ref{sec:preservation}) then all data can be lost. To combat this (as mentioned above) extra work is needed on the programmers behalf to move these objects into non-volatile memory, this not only give the programmer more work, but also increases the load that a program puts on the system due to database calls which in a lot of languages are ``unable to benefit from compile-time verification and design-time features like IntelliSense.''\citep{XML}.
\subsubsection{Pros}
Despite the cons mentioned in section~\ref{sec:cons} there are still a few pros of working in a conventional system. The main one being the use of relational databases to implement persistence and the loose coupling achieved through utilizing one~\citep{Databases}.
A database stores many kinds of data in a standardised way for access by numerous different programs, this creates a loose coupling between the program and its persistent data, making it easier to create generic light-weight reports to run over large sets of data without having to write large programs that incorporate this functionality.
\subsection{Orthogonal Persistence}\label{sec:orthogonal}
Also known as transparent persistence, orthogonal persistence is an implementation of persistence where the programmer doesn't need to invoke persistence in order to use it, for this to happen the persistence property should happen in the background, transparent to the programmer and any users.
Three principles of persistence were identified by Atkinson and Morrison \citep{Atkinson}, these principles are as follows:
\begin{enumerate}
    \item{The Principle of Persistence Independence - Programmer shouldn't be have to invoke persistence}
    \item{The Principle of Data Type Orthogonality - All data objects are allowed to be persisted}
    \item{The Principle of Persistence Identification - The choice of how to identify persistent objects is orthogonal to the universe of discourse of the system}
\end{enumerate}
\subsection{Implementations of Persistence}\label{sec:persistentLanguages}
The following sections will introduce some persistent programming languages including some of the hurdles encountered with each implementation. These implementations will be compared with the definition of orthogonal persistence given in Section~\ref{sec:orthogonal}.
%PS-algol
\subsubsection{PS-Algol}
%Introduction
An extension of S-Algol, PS-Algol was the first orthogonally persistent programming language. The compiler was largely unchanged as the persistence extensions were implemented at run-time, with a lot of them being functions that worked with the database such as:
\begin{itemize}
    \item{open.database(...)}
    \item{close.database(...)}
    \item{commit}
    \item{abandon}
    \item{lookup(...)}
    \item{enter(...)}
\end{itemize}
%how it compares to the orthogonal persistence model
When an object is first accessed it is automatically bound to a representation in the database~\citep{psalgol} (regardless of its type) and is used throughout the objects life cycle, this helps to achieve the principals of data type orthogonality and persistence identification. This action is done automatically meaning the programmer doesn't need to explicitly move the data between mediums thus achieving persistence independence.
%Napier88
\subsubsection{Napier88}
%introduction - brief desc of the language
Napier88 is another orthogonally persistent programming language\citep{napier}, it differs from PS-Algol in the following improvements~\citep{ADearle} (among others):
\begin{itemize}
    \item{The infinite union type `any'}
    \item{The infinite union type `environment'} 
    \item{Parametric polymorphism}
    \item{Support for structural reflection}
\end{itemize}
%how it compares to the orthogonal persistence model
Napier88 represents a fully integrated persistent environment that makes use of `text' and `hyperlinks' to aid in achieving the principals of persistence independence and data type orthogonality.
\subsubsection{Java}
Out-of-the-box Java is a transient programming language however it does provide interfaces to the programmer to make objects persist. In addition the Java Virtual Machine (JVM) aids in creating persistent systems (see sections~\ref{sec:grasshopper}, \ref{sec:pjama} and \ref{sec:anuopj}) largely due to the abstraction it provides over the conventional operating system is runs on. Following are some persistence implementations.
\paragraph{Java Serialization}
Java provides interfaces for object serialization and deserialization to assist in persistence, these interfaces make the tasks of writing to and reading from secondary storage simple. Objects must implement the java.io.serializable interface in order to become persistent in this manner, which breaks the rule of data type orthogonality. Data persisted in this manner must also be explicitly written which means it also breaks the principal of persistence independence~\citep{ADearle}.
\paragraph{Java's Hibernate}
%introduction - brief desc of the method
Because Java is so commonly used for large enterprise applications~\citep{persistenceandjava} there have been a few persistence API's developed. These API's abstract the persistence processes (such as the object to relationship mappings) in order to speed up development time. 
\\One of these persistence API's is Hibernate (not to be confused with section~\ref{sec:hibernate} of this report). Hibernate builds on top of the Enterpise JavaBeans (EJB) and the Java Persistence API's, its main purpose is that of an object-relational mapping (ORM) library~\citep{hibernateORM} which means it creates the mappings between in-memory objects and database tables (thus assisting to provide persistence). Hibernate doesn't provide orthogonal persistence for the following reasons:
\begin{itemize}
    \item{Objects can be marked as persistent or transient, breaking the principal of data type orthogonality}
    \item{A store function must be invoked to perform updates or inserts in the database, breaking the principal of persistence independence}
\end{itemize}
Despite not being orthogonally persistent Hibernate is still widely used in industry.
\paragraph{PJama}\label{sec:pjama}
%introduction - brief desc of the method
PJama is is a Java system built for persistence, it uses a modified interpreter to run Java programs~\citep{persistentjavasystem} in a persistent manner. PJama can not persist some types~\citep{ADearle}, failing the principal of data type orthogonality. 
%problems encountered
%how it compares to the orthogonal persistence model
\paragraph{ANU-OPJ}\label{sec:anuopj}
%introduction - brief desc of the method 
%problems encountered
%how it compares to the orthogonal persistence model
\paragraph{Language Integrated Query (LINQ)}
%introduction - brief desc of the method 
%problems encountered
%how it compares to the orthogonal persistence model
\paragraph{Grasshopper}\label{sec:grasshopper}
%introduction - brief desc of the language
%problems encountered
%how it compares to the orthogonal persistence model
\subsection{Persistent Operating Systems}\label{sec:persistentOS}
The components of a persistent system are different to those of a conventional operating system~\citep{Grasshopper} 
\subsubsection{Global Consistency}
\paragraph{Global Checkpointing}
\paragraph{Asynchronous Checkpointing}
\paragraph{Synchronous Checkpointing}
\subsection{Limitations}\label{sec:limitations}
\subsection{Summary}
\section{System State Preservation}\label{sec:preservation}
The state of a system refers to the data and processes that live in that state. The state within conventional operating systems exists in a transient manner, this means that if a failure occurs the state can cease to exist (contrary to the persistent systems mentioned in section~\ref{sec:persistentOS}). In a perfect world this would not matter however we do not live in a perfect world. We need to consider inconsistencies such as:
\begin{itemize}
    \item{Power failures}
    \item{Data corruption}
    \item{Limited storage capacity}
    \item{Limited processing power}
    \item{Limited power (encouraging users to close laptop lids or power down machines regularly)}
\end{itemize}
For these reasons we need to develop methods that allow us to recover from the above mentioned inconsistencies, in such a way that once the system comes back online and usable the user can continue to work as if nothing had happened.
\\There are a few different methods already developed for this exact purpose, some for useful than others and some that use more resources than others. Sections~\ref{sec:lowpower} and~\ref{sec:memorydump} group these methods by behavior.

\subsection{Low-power}\label{sec:lowpower}
The first group of methods that implement System State Preservation share the characteristic (or requirement) that the system is still running, albeit consuming minimal power. These methods keep primary storage powered while other components of the system are shut down. In these methods the system does not need to write anything to secondary storage upon initiation and therefor will not need to read anything on system startup. For this reason these methods are preferable in systems using solid state drives (SSD), additionally these types of preservation are generally the quickest methods (only having to wait for all other components to come back online).
\\The following sections describe some examples of these method of System State Preservation.

\subsubsection{Suspend to RAM}\label{sec:stRam}
This is a method used by the Linux operating system where power is cut to all components of the system except for RAM which contains all the information in relation to system state.\citep{Wiki}
Suspend to RAM can be initiated by a user or scheduled by the system to save power when the system isn't being directly used. Suspend to RAM is not useful following a complete sudden loss of power due to a power.
\subsubsection{PC box Power Management (PCPM)}\label{sec:PCPM}
Used by most Windows computers since Windows 2000, PCPM refers to a form of system state preservation concerned with lowering power consumption of the PC (hard drive, CPU, etc.)~\citep{PCPM} usually to save laptop battery life or to meet energy standards set by Energy Star in conjunction with Advanced Configuration Power Interface (ACPI)~\citep{PCPM}.
\\This method is similar to Linux's method mentioned in section~\ref{sec:stRam} often referred to as ``sleep'', however some difficulties arose when networking started becoming popular in the industry. Today we see a lot of centrally managed computer environments where an organisation will image all their computers the same way and ``push'' updates when necessary. This became a problem when PCPM was first used as the computer would become disconnected from the network during system sleep, for this reason it has been necessary to activate the Wake On Lan (WOL) feature of the operating system. WOL makes it possible for administrators to ``wake'' a computer from ``sleep'' by sending a message through the network interface~\citep{WOL} making it possible for administrators to remotely issue updates. For WOL to function the network interface must be powered as well as the RAM and this is the main difference between PCPM and Suspend to RAM mentioned in section~\ref{sec:stRam}.

\subsection{Memory dump}\label{sec:memorydump}
The next group of methods share the characteristic that they all write the systems state to secondary (non-volatile) storage and completely shut down, this means that the next system start up will function just like a cold start up except that once the system is ready it will read the last valid system state back into ram.
These methods are the most useful in dealing with laptops that have run out of battery power providing the operating system is configured to perform a system state write before all power is completely lost. These methods are still vulnerable to complete and sudden power losses because they need time to perform the write operations.
\subsubsection{Hibernate}\label{sec:hibernate}
Hibernate is the main implementation of System State Preservation where the entire state is written to secondary storage. It is implemented in most modern operating systems, namely Windows 2000+ (support existed at the hardware level of Windows 95), Mac OSX 10.4+, and Linux since kernel 2.6.
Hibernate can be invoked by a user, scheduled by the system (after a certain period of inactivity) or forced when a low-power state is detected (less than 5\% battery power), upon invocation the operating system will write the entire contents of RAM to non-volatile secondary storage and commence a complete power down.
\paragraph{Suspend to Disk}\label{sec:stDisk}
An implementation of hibernate used in the Linux operating system since kernel 2.6, the entire systems state is saved into swap space and the machine is completely powered off.\citep{Wiki}
\subsection{Hybrid Methods}
As the name suggests these methods are a combination of Sleep and Hibernate. Sections~\ref{sec:stBoth}, \ref{sec:hybridsleep} and \ref{sec:safesleep} explain how Linux, Windows and Apple operating systems (respectively) implement this form of preservation.
Generally these methods write the system state to secondary storage and then enter their low power state (see section~\ref{sec:lowpower}). This means that the system is protected from a total power loss while still allowing for quicker startup times (when compared to the methods mentioned in \ref{sec:memorydump}) provided the power isn't completely lost. 
\subsubsection{Suspend to Both}\label{sec:stBoth}
The Linux implementation of Hybrid Sleep, this is a combination of the methods explained in section~\ref{sec:stRam} and section~\ref{sec:stDisk}
\subsubsection{Hybrid Sleep}\label{sec:hybridsleep}
This method is used by Windows operating systems since Vista.
\subsubsection{Safe Sleep}\label{sec:safesleep}
\paragraph{Versioning}
In addition to Safe Sleep, the latest versions of Mac OSX (10.8+) also exposes an api for automatic versioning. This api makes it easy for developers to create programs that act in a persistent manner, applications can now be configured to automatically save the users work in the background. 
Programs that enable this functionality contribute to making OSX a resilient and reliable system because even if Safe Sleep fails completely the automatic versioning should still have a recent copy of the users work to access.
\subsection{Advance Configuration and Power Interface (ACPI)}
The ACPI defines the current standards for power management \citep{ACPI} and as such have categorized all the methods described throughout this section on system state preservation (section~\ref{sec:preservation}). Table~\ref{table:categories} outlines where these methods are rated in terms of power usage.
\begin{table}[h!]
    \begin{center}
        \leavevmode
        \begin{tabular}{|cll|l|}\hline
            Method & Section & Category\\[0.1cm]\hline
            Suspend to RAM & \ref{sec:stRam} & S3\\
            PCPM & \ref{sec:PCPM} & S3 \\
            Hibernate & \ref{sec:hibernate} & S4\\
            Suspend to Disk & \ref{sec:stDisk} & S4 \\
            Suspend to Both & \ref{sec:stBoth} & S3 \\
            Hybrid Sleep & \ref{sec:hybridsleep} & S3 \\
            Safe Sleep & \ref{sec:safesleep} & S3 \\\hline
        \end{tabular}
    \end{center}
    \caption{ACPI power saving categories \citep{ACPI}}
    \label{table:categories}
\end{table}
\\S3 refers to all methods that consume ``low power'' and S4 refers to methods where absolutely no power is used \citep{ACPI}. S1 and S2 do exist (along with many others) but are not concerned with system state preservation and are not included in this report.
\subsection{Summary}
\newpage
\section{Discussion}\label{sec:discussion}
%compare and contrast
Given a completely persistent system there would be no need for methods that preserve a systems state.
%
\section{Conclusion}
%
A brief final summary of the main achievements and outcomes. Possibly some suggestions for future work that can follow on from your project.%
%
\subsection*{Acknowledgements}
The author is grateful to A/Prof Frans Henskens and Mark Wallis for the content presented throughout the course, and to Michaela Burgess for proof reading this report.
\newpage
\section{Glossary}
\textbf{API:}
\\\textbf{Non-volatile:}
\\\textbf{Object Relational Mapper (ORM):} 
\\\textbf{Push:} Copying data from a source to one or many destinations. 
\\\textbf{Volatile:}
%

\vskip 0.2in
\newpage
\bibliographystyle{apalike}
\bibliography{./literature.bib}

\end{document}
